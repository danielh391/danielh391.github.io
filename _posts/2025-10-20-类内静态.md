---
layout:     post
title:      类内静态
subtitle:   
date:       2025-10-20
author:     danielh
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - cpp语法


---
# 类中静态变量/函数有什么作用，举简单例子说明一下

类中静态变量和函数的主要作用是实现**类级别的共享**，而不是实例级别的。下面用简单例子说明：

## 1. 静态变量（类变量）

### 计数器功能
```cpp
class Student {
public:
    static int count;  // 静态变量 - 统计学生总数
    
    Student() {
        count++;  // 每创建一个学生，计数器+1
    }
};

// 类外定义静态变量
int Student::count = 0;

int main() {
    Student s1, s2, s3;
    cout << "学生总数: " << Student::count;  // 输出: 3
    return 0;
}
```

### 共享配置
```cpp
class Config {
public:
    static string schoolName;  // 所有学生共享的学校名
};

string Config::schoolName = "第一中学";

int main() {
    cout << Config::schoolName;  // 输出: 第一中学
    return 0;
}
```

## 2. 静态函数

### 工具函数
```cpp
class MathUtils {
public:
    static int add(int a, int b) {  // 静态函数
        return a + b;
    }
    
    static double getPI() {         // 静态函数
        return 3.14159;
    }
};

int main() {
    // 直接通过类名调用，不需要创建对象
    cout << MathUtils::add(5, 3);    // 输出: 8
    cout << MathUtils::getPI();      // 输出: 3.14159
    return 0;
}
```

### 访问静态变量
```cpp
class BankAccount {
private:
    static double interestRate;  // 私有静态变量
    
public:
    static void setInterestRate(double rate) {  // 静态函数可以访问静态变量
        interestRate = rate;
    }
    
    static double getInterestRate() {
        return interestRate;
    }
};

double BankAccount::interestRate = 0.03;

int main() {
    cout << "当前利率: " << BankAccount::getInterestRate();  // 输出: 0.03
    BankAccount::setInterestRate(0.035);
    cout << "新利率: " << BankAccount::getInterestRate();    // 输出: 0.035
    return 0;
}
```

## 3. 综合例子

```cpp
class Car {
public:
    static int totalCars;     // 静态变量 - 汽车总数
    string brand;
    
    Car(string b) : brand(b) {
        totalCars++;
    }
    
    // 静态函数
    static int getTotalCars() {
        return totalCars;
    }
    
    static void resetCounter() {
        totalCars = 0;
    }
};

int Car::totalCars = 0;

int main() {
    Car car1("Toyota");
    Car car2("Honda");
    Car car3("BMW");
    
    cout << "总共创建了 " << Car::getTotalCars() << " 辆车";  // 输出: 3
    
    Car::resetCounter();
    cout << "重置后: " << Car::getTotalCars();  // 输出: 0
    
    return 0;
}
```

## 主要作用总结：

| 类型 | 作用 | 特点 |
|------|------|------|
| **静态变量** | 类级别的数据共享 | 所有对象共享同一份数据 |
| **静态函数** | 类级别的操作 | 不需要对象就能调用，只能访问静态成员 |

### 关键特点：
- ✅ **静态变量**：内存中只有一份，所有对象共享
- ✅ **静态函数**：通过 `类名::函数名()` 调用
- ❌ **静态函数**：不能访问非静态成员（因为没对象）
- ✅ **适用场景**：计数器、配置信息、工具函数、单例模式

# 类内成员函数都可以访问类内静态成员变量吗
**是的，类内的所有成员函数都可以访问类内的静态成员变量**，无论这些成员函数是普通成员函数、静态成员函数、const成员函数，还是构造函数、析构函数。

## 1. 普通成员函数访问静态变量

```cpp
class Example {
private:
    static int count;        // 静态变量
    int id;                  // 普通成员变量
    
public:
    Example() {
        id = ++count;        // 构造函数访问静态变量
        cout << "创建对象，ID: " << id << endl;
    }
    
    void display() {         // 普通成员函数
        cout << "对象ID: " << id << ", 总数: " << count << endl;
    }
    
    void increment() {       // 普通成员函数修改静态变量
        count++;
    }
};

int Example::count = 0;

int main() {
    Example e1, e2;
    e1.display();  // 输出: 对象ID: 1, 总数: 2
    e2.increment();
    e2.display();  // 输出: 对象ID: 2, 总数: 3
    return 0;
}
```

## 2. 静态成员函数访问静态变量

```cpp
class Bank {
private:
    static double interestRate;  // 静态变量
    static int totalAccounts;    // 静态变量
    
public:
    // 静态成员函数只能访问静态成员
    static void setInterestRate(double rate) {
        interestRate = rate;
    }
    
    static double getInterestRate() {
        return interestRate;
    }
    
    static int getTotalAccounts() {
        return totalAccounts;
    }
    
    Bank() {
        totalAccounts++;  // 构造函数访问静态变量
    }
};

double Bank::interestRate = 0.03;
int Bank::totalAccounts = 0;

int main() {
    Bank b1, b2, b3;
    cout << "总账户数: " << Bank::getTotalAccounts() << endl;  // 输出: 3
    Bank::setInterestRate(0.035);
    cout << "利率: " << Bank::getInterestRate() << endl;       // 输出: 0.035
    return 0;
}
```

## 3. const成员函数访问静态变量

```cpp
class Student {
private:
    static int nextId;
    static int totalStudents;
    int id;
    string name;
    
public:
    Student(string n) : name(n) {
        id = nextId++;
        totalStudents++;
    }
    
    // const成员函数可以读取静态变量
    void display() const {
        cout << "学生ID: " << id << ", 姓名: " << name << endl;
        cout << "总学生数: " << totalStudents << endl;  // 正确：读取静态变量
    }
    
    // const成员函数不能修改普通成员变量，但可以读取静态变量
    void showInfo() const {
        // id = 100;  // 错误：const函数不能修改普通成员变量
        cout << "下一个可用ID: " << nextId << endl;  // 正确：读取静态变量
    }
};

int Student::nextId = 1;
int Student::totalStudents = 0;
```

## 4. 各种成员函数综合示例

```cpp
#include <iostream>
#include <string>
using namespace std;

class Car {
private:
    static int totalCars;        // 静态变量
    static int nextId;
    int id;
    string brand;
    double price;
    
public:
    // 构造函数
    Car(string b, double p) : brand(b), price(p) {
        id = nextId++;
        totalCars++;
        cout << "创建汽车 ID: " << id << endl;
    }
    
    // 析构函数
    ~Car() {
        totalCars--;
        cout << "销毁汽车 ID: " << id << endl;
    }
    
    // 普通成员函数
    void display() {
        cout << "ID: " << id << ", 品牌: " << brand << ", 价格: " << price << endl;
        cout << "当前总车辆: " << totalCars << endl;
    }
    
    // const成员函数
    void showInfo() const {
        cout << "车辆 " << id << " - " << brand << endl;
        cout << "市场上总车辆: " << totalCars << endl;  // 可以读取静态变量
    }
    
    // 静态成员函数
    static int getTotalCars() {
        return totalCars;
    }
    
    static void resetCounter() {
        totalCars = 0;
        nextId = 1;
    }
    
    // 修改价格的普通函数
    void setPrice(double newPrice) {
        price = newPrice;
        cout << "修改价格，当前总车辆数: " << totalCars << endl;
    }
};

int Car::totalCars = 0;
int Car::nextId = 1;

int main() {
    Car car1("Toyota", 200000);
    Car car2("Honda", 180000);
    
    car1.display();      // 普通成员函数访问静态变量
    car2.showInfo();     // const成员函数访问静态变量
    
    cout << "通过静态函数访问: " << Car::getTotalCars() << endl;
    
    car1.setPrice(190000);  // 修改价格时也访问了静态变量
    
    return 0;
}
```

## 5. 访问控制的影响

```cpp
class AccessExample {
private:
    static int privateStatic;   // 私有静态变量
    int privateNormal;          // 私有普通变量
    
public:
    static int publicStatic;    // 公有静态变量
    
    // 所有成员函数都可以访问私有静态变量
    void normalFunction() {
        privateStatic = 100;    // 正确：可以访问私有静态
        privateNormal = 50;     // 正确：可以访问私有普通
    }
    
    static void staticFunction() {
        privateStatic = 200;    // 正确：静态函数可以访问私有静态
        // privateNormal = 60;  // 错误：静态函数不能访问普通成员
    }
    
    void constFunction() const {
        // privateStatic = 300; // 错误：const函数不能修改任何变量
        int temp = privateStatic;  // 正确：可以读取静态变量
        // privateNormal = 70;  // 错误：const函数不能修改普通成员
    }
};

int AccessExample::privateStatic = 0;
int AccessExample::publicStatic = 0;
```

## 总结

| 函数类型 | 能否访问静态变量 | 能否修改静态变量 | 说明 |
|----------|------------------|------------------|------|
| 普通成员函数 | ✅ | ✅ | 完全访问权限 |
| 静态成员函数 | ✅ | ✅ | 只能访问静态成员 |
| const成员函数 | ✅ | ❌ | 只能读取，不能修改 |
| 构造函数 | ✅ | ✅ | 完全访问权限 |
| 析构函数 | ✅ | ✅ | 完全访问权限 |

**关键点：**
- ✅ **所有成员函数**都可以访问静态成员变量
- ✅ **静态函数**只能访问静态成员，不能访问普通成员
- ❌ **const函数**可以读取静态变量，但不能修改
- 🔒 **访问控制**（public/private）影响的是类外访问，类内所有函数都可以访问所有成员

# 类内静态成员函数可以访问类内成员变量吗
**不可以，类内的静态成员函数不能访问类内的普通成员变量。**

静态成员函数只能访问静态成员（静态变量和静态函数），不能访问普通成员变量。

## 1. 基本规则演示

```cpp
class Example {
private:
    int normalVar;          // 普通成员变量
    static int staticVar;   // 静态成员变量
    
public:
    Example(int val) : normalVar(val) {}
    
    // 静态成员函数
    static void staticFunction() {
        staticVar = 100;    // ✅ 正确：可以访问静态变量
        // normalVar = 50;  // ❌ 错误：不能访问普通成员变量
    }
    
    // 普通成员函数
    void normalFunction() {
        normalVar = 50;     // ✅ 正确：可以访问普通成员变量
        staticVar = 100;    // ✅ 正确：可以访问静态变量
    }
};

int Example::staticVar = 0;
```

## 2. 为什么不能访问？

```cpp
class Student {
private:
    string name;           // 普通成员变量 - 属于对象
    int age;               // 普通成员变量 - 属于对象
    static int totalStudents;  // 静态变量 - 属于类
    
public:
    Student(string n, int a) : name(n), age(a) {
        totalStudents++;
    }
    
    // 静态函数 - 没有this指针
    static void printTotal() {
        cout << "总学生数: " << totalStudents << endl;  // ✅ 正确
        
        // ❌ 以下都是错误的：
        // cout << "姓名: " << name << endl;    // 错误：哪个对象的name？
        // cout << "年龄: " << age << endl;     // 错误：哪个对象的age？
        // this->name = "Tom";                  // 错误：静态函数没有this指针
    }
    
    // 普通函数 - 有this指针
    void printInfo() {
        cout << "姓名: " << name << endl;       // ✅ 正确：this->name
        cout << "年龄: " << age << endl;        // ✅ 正确：this->age
        cout << "总数: " << totalStudents << endl; // ✅ 正确
    }
};

int Student::totalStudents = 0;
```

## 3. 实际例子说明

```cpp
#include <iostream>
#include <string>
using namespace std;

class Car {
private:
    string brand;           // 普通成员变量
    double price;           // 普通成员变量
    static int totalCars;   // 静态成员变量
    static double totalValue; // 静态成员变量
    
public:
    Car(string b, double p) : brand(b), price(p) {
        totalCars++;
        totalValue += price;
    }
    
    ~Car() {
        totalCars--;
        totalValue -= price;
    }
    
    // 静态函数 - 只能访问静态成员
    static void showStatistics() {
        cout << "=== 汽车统计 ===" << endl;
        cout << "总数量: " << totalCars << endl;        // ✅ 正确
        cout << "总价值: " << totalValue << endl;       // ✅ 正确
        
        // ❌ 以下都是错误的：
        // cout << "品牌: " << brand << endl;           // 错误
        // cout << "价格: " << price << endl;           // 错误
        // cout << "平均价格: " << totalValue / totalCars << endl; // ✅ 正确（用静态变量计算）
    }
    
    // 普通函数 - 可以访问所有成员
    void showCarInfo() {
        cout << "品牌: " << brand << endl;              // ✅ 正确
        cout << "价格: " << price << endl;              // ✅ 正确
        cout << "总数量: " << totalCars << endl;        // ✅ 正确
    }
    
    // 静态函数返回静态变量
    static int getTotalCars() {
        return totalCars;   // ✅ 正确
    }
    
    static double getAveragePrice() {
        if (totalCars > 0) {
            return totalValue / totalCars;  // ✅ 正确：用静态变量计算
        }
        return 0;
    }
};

int Car::totalCars = 0;
double Car::totalValue = 0;

int main() {
    Car::showStatistics();  // 不需要对象就能调用静态函数
    
    Car car1("Toyota", 200000);
    Car car2("Honda", 180000);
    
    Car::showStatistics();  // 输出统计信息
    
    car1.showCarInfo();     // 输出具体车辆信息
    
    cout << "平均价格: " << Car::getAveragePrice() << endl;
    
    return 0;
}
```

## 4. 解决方案：如果需要访问普通成员

```cpp
class BankAccount {
private:
    string accountNumber;   // 普通成员变量
    double balance;         // 普通成员变量
    static double interestRate;  // 静态变量
    
public:
    BankAccount(string accNo, double bal) : accountNumber(accNo), balance(bal) {}
    
    // 静态函数 - 无法直接访问普通成员，但可以通过参数传递
    static void applyInterest(BankAccount& account) {
        // 通过传入的对象引用访问其普通成员
        account.balance += account.balance * interestRate;
        cout << "为账户 " << account.accountNumber << " 应用利息" << endl;
    }
    
    // 静态函数 - 通过指针访问
    static void applyInterest(BankAccount* account) {
        if (account) {
            account->balance += account->balance * interestRate;
        }
    }
    
    // 普通函数调用静态函数
    void applyMyInterest() {
        BankAccount::applyInterest(*this);  // 传递当前对象
    }
    
    void display() {
        cout << "账户: " << accountNumber << ", 余额: " << balance << endl;
    }
    
    static void setInterestRate(double rate) {
        interestRate = rate;
    }
};

double BankAccount::interestRate = 0.03;

int main() {
    BankAccount acc1("12345", 1000);
    BankAccount acc2("67890", 2000);
    
    // 方式1：通过静态函数传入对象
    BankAccount::applyInterest(acc1);
    acc1.display();
    
    // 方式2：通过普通函数调用静态函数
    acc2.applyMyInterest();
    acc2.display();
    
    return 0;
}
```

## 5. 访问控制的影响

```cpp
class AccessExample {
private:
    int privateNormal;          // 私有普通成员
    static int privateStatic;   // 私有静态成员
    
public:
    int publicNormal;           // 公有普通成员
    static int publicStatic;    // 公有静态成员
    
    // 静态函数
    static void staticFunction() {
        privateStatic = 100;    // ✅ 正确：可以访问私有静态
        publicStatic = 200;     // ✅ 正确：可以访问公有静态
        
        // ❌ 以下都是错误的：
        // privateNormal = 50;  // 错误：不能访问普通成员（即使是公有的）
        // publicNormal = 60;   // 错误：不能访问普通成员（即使是公有的）
    }
};

int AccessExample::privateStatic = 0;
int AccessExample::publicStatic = 0;
```

## 总结

| 函数类型 | 可以访问 | 不能访问 | 原因 |
|----------|----------|----------|------|
| **静态成员函数** | 静态变量、静态函数 | 普通成员变量、普通成员函数 | 没有this指针 |
| **普通成员函数** | 所有成员（静态+普通） | 无限制 | 有this指针 |

**关键原因：**
- 静态函数属于**类**，不依赖于任何对象
- 静态函数**没有this指针**
- 普通成员变量属于**对象**，需要this指针来访问
- 静态函数在对象创建之前就可以调用

**使用场景：**
- 静态函数适合：工具函数、工厂方法、访问静态数据
- 普通函数适合：操作对象特定数据、需要访问对象状态的操作
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM2Nzg0NjE4MywtMTU5MTA3ODAwNl19
-->