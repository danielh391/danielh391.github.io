---
layout:     post
title:      网络中的地址表
subtitle:   计算机网络传输过程中，有哪些地址表汇总
date:       2025-08-26
author:     danielh
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - 网络


---
在计算机网络传输过程中，为了正确地在复杂的网络环境中寻址和转发数据，各种网络设备（如交换机、路由器）会维护多种关键的**地址表**。这些表是设备的“大脑”和“导航图”。

以下是主要的地址表及其作用的总结：

| 地址表 | 核心作用 | 工作层次 | 关键信息 | 所在设备 |
| :--- | :--- | :--- | :--- | :--- |
| **MAC地址表** | **局域网内部寻址** | 数据链路层 (L2) | MAC地址 ➔ 交换机端口 | 交换机、网桥 |
| **ARP表** | **IP地址 → MAC地址 的映射** | 网络层/数据链路层 | IP地址 ➔ MAC地址 | 主机、路由器 |
| **路由表** | **跨网络路径选择** | 网络层 (L3) | 目标网络 ➔ 下一跳/出接口 | 路由器、主机 |
| **NAT表** | **公私网地址转换** | 网络层/传输层 | 内网IP:Port ➔ 外网IP:Port | 路由器、防火墙 |

为了更清晰地理解这些表如何协同工作，完成一次从内网到公网的完整通信流程，下图展示了数据包在传输过程中如何被这些表处理：

![](/imgs/2025-08-26/ydx60itcJLPoWTgW.png)
---

### 各地址表详解

#### 1. MAC 地址表 (MAC Address Table) / CAM 表
*   **所在设备**：**交换机**、**网桥**。
*   **作用**：用于在**同一个局域网内**进行**二层交换**。它记录了每个设备（由其MAC地址标识）连接在交换机的哪个物理端口上。
*   **工作过程**：
    1.  **学习**：交换机从某个端口收到一个数据帧时，会查看帧的**源MAC地址**，并将该地址和端口的映射关系记录在MAC地址表中。
    2.  **转发**：当需要转发数据帧时，交换机会查看帧的**目标MAC地址**，然后查表。如果找到记录，就从对应的端口**精准转发**出去；如果找不到，就向**所有端口广播**（泛洪）。
*   **特点**：表项通常有老化时间，一段时间不通信就会自动删除。

#### 2. ARP 表 (ARP Table / ARP Cache)
*   **所在设备**：**主机**、**路由器**（任何有IP协议的设备）。
*   **作用**：实现**IP地址**到**MAC地址**的解析。因为在局域网内最终通信是靠MAC地址，但应用程序使用的是IP地址。
*   **工作过程**：
    1.  设备A想和设备B（IP地址已知）通信，但不知道B的MAC地址。
    2.  设备A**查询ARP表**。如果已有B的IP->MAC映射，则直接使用。
    3.  如果没有，设备A会发送一个**ARP广播请求**：“谁的IP地址是B？请告诉A。”
    4.  设备B收到后，会**单播回复**：“我是B，我的MAC地址是XX:XX:XX。”
    5.  设备A收到回复后，将这条映射关系存入自己的**ARP缓存**，然后进行通信。
*   **特点**：表项也有生存时间（TTL），到期后自动删除，需要时重新查询，以适应网络变化。

#### 3. 路由表 (Routing Table)
*   **所在设备**：**路由器**、**主机**（有基本路由能力）。
*   **作用**：用于**跨网络**的**三层路由**。它像一个地图，告诉设备要去往某个目标IP网络，数据包应该从哪个接口发出，或者发给哪个“下一跳”路由器。
*   **内容来源**：
    *   **直连路由**：自动生成，来自路由器自身接口配置的网络。
    *   **静态路由**：管理员手动配置。
    *   **动态路由**：通过OSPF、BGP等动态路由协议从其他路由器学习而来。
*   **核心原则**：**最长前缀匹配**。路由器会选择最具体的路由（子网掩码最长的那条）。

#### 4. NAT 表 (NAT Table)
*   **所在设备**：**路由器**、**防火墙**（通常位于网络边界，如家用的无线路由器）。
*   **作用**：实现**网络地址转换**，解决IPv4公网地址不足的问题。它将内网设备的私有IP地址和端口号，映射为对公网可见的公网IP地址和端口号。
*   **工作过程**：
    1.  内网主机（`192.168.1.100:1234`）访问公网服务器。
    2.  边界路由器将数据包的源地址替换为公网IP和一个新端口（`公网IP:5678`），并**将这条映射关系记录在NAT表中**。
    3.  公网服务器将响应发回给路由器的公网IP和端口（`公网IP:5678`）。
    4.  路由器收到响应后，**查询NAT表**，发现`5678`端口对应内网的`192.168.1.100:1234`，于是将数据包的目的地址替换回去，并转发给内网主机。

### 总结

这些地址表协同工作，共同保证了数据包能够高效、准确地在网络世界中穿梭：
*   **ARP表**解决了“**这个IP是谁**”（对应哪个MAC）的问题。
*   **MAC地址表**解决了“**这个设备在哪**”（在交换机哪个端口）的问题，负责**局域网内**的精准投递。
*   **路由表**解决了“**去往目标网络该走哪条路**”的问题，负责**跨网络**的宏观导航。
*   **NAT表**解决了“**如何用少量公网IP让大量内网设备上网**”的地址转换问题。

#### 假设地址表都为空的情况下，我们看看发生了什么

首先，可以分为两种情况，目标是否在在同一局域网。
![](/imgs/2025-08-26/ezRhQAhJQz6rASvL.png)
上图展示了最根本的区别：**主机A永远不会也不需要知道远程主机B的MAC地址**。它只需要知道**如何把数据包送到网关**即可，剩下的工作由网关负责。

以 **计算机A（IP_A, MAC_A） ping 计算机B（IP_B, MAC_B）** 为例，它们连接在同一台交换机上，在局域网当中。数据传输只需要经过交换机，不需要经过路由器。

![](/imgs/2025-08-26/JvxiZxNzaQMx1FNV.png)

当目标B主机在远程，又会发生什么呢？

这引出了网络通信中最核心的概念之一：**网关（Gateway）**。当目标不在同一局域网时，过程会发生关键性变化，从“直接问本人”变成了“问网关帮忙转交”。我们假设：
-   **计算机A**： `IP_A`/`MAC_A`，在局域网 `192.168.1.0/24`
    
-   **网关路由器**：`IP_GW`/`MAC_GW`（例如 `192.168.1.1`），连接A的局域网和互联网。
    
-   **计算机B**：在遥远的互联网上，`IP_B`（例如 `8.8.8.8`）。

#### 第1步：A判断目标网络（逻辑判断）

1.  A配置了自己的IP地址（`IP_A`）和子网掩码（比如 `255.255.255.0`）。
    
2.  A将目标地址 `IP_B` 和自己的子网掩码进行逻辑“与”运算，判断出 `IP_B` 的网络号与自己不在同一个网络。
    
3.  **结论**：”B不在我家院子里，我得把包交给管家（网关）让他寄出去。“
    

#### 第2步：ARP请求网关的MAC地址（关键步骤）

1.  A查看自己的ARP表，寻找网关IP地址 `IP_GW` 对应的MAC地址。**表是空的**。
    
2.  A**发起一个ARP广播请求**（目标MAC: `FF:FF:FF:FF:FF:FF`）：
    
    -   **“谁是 `192.168.1.1`（IP_GW）？请告诉 `192.168.1.100`（IP_A）。”**
        
3.  交换机收到广播，进行洪泛。
    
4.  网关路由器收到这个ARP请求，发现是问自己的，于是**发送ARP单播回复**：
    
    -   **“我是 `192.168.1.1`，我的MAC地址是 `MAC_GW`。”**
        
5.  A收到回复，**在自己的ARP表中添加一条记录：`IP_GW -> MAC_GW`**。
    
    -   **此时，A的ARP表里依然没有B的记录，也永远不会有。**
        

#### 第3步：封装并发送数据包（目的MAC是网关）

1.  A开始封装要发送的Ping请求（ICMP Echo Request）数据包。
    
    -   **网络层（IP头）**：
        
        -   源IP: `IP_A`
            
        -   **目标IP: `IP_B`** （最终目标不变）
            
    -   **数据链路层（帧头）**：
        
        -   源MAC: `MAC_A`
            
        -   **目标MAC: `MAC_GW`** （**关键变化！下一跳的地址**）
            
2.  A将这个数据帧发送出去。
    

#### 第4步：交换机转发至网关

1.  交换机收到帧，查看源MAC（`MAC_A`），**学习：`MAC_A` 在端口1**。
    
2.  查看目标MAC（`MAC_GW`），查表。**表是空的（或还没有`MAC_GW`的记录）**。
    
3.  交换机**洪泛**该数据帧。
    
4.  网关路由器（MAC地址正好是 `MAC_GW`）接收到该帧。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY5MTA2Nzk0MSwtNzE2NTk5MjgyLC04MT
g3NTk5MTcsLTgxODc1OTkxN119
-->